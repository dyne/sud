@code_type c .c
@comment_type // %s
@compiler literate/bin/lit -t sud.lit && gcc sud.c && rm a.out

@title Super User Do

@s Multi-user privilege escalation tool

This software aims to be a UNIX tool for generic secure usage when in
need of privilege escalation. It is designed to run SUID, with
"super-user powers" to execute things as root on the system it is
installed. As such, it is designed for security, leveraging all
possible measures to avoid vulnerabilities, including the reduction of
complexity in its own source-code.

The purpose of `sud` is to execute commands as root (super-user) or as
other users that are configured on the system. For its configuration
and authorization of users who can access its services, it relies on a
simple config file: `/etc/sudrc`.

The config file format is a simple sequence of keys and values, all
strings separated by an equal sign `=`.

@s Code structure overview

The overall structure of `sud` source-code is defined by this
`Literate` program `sud.lit`:

--- sud.c
@{Header files of system dependencies}
@{Preprocessor definitions}
@{Global variables}
@{Local functions}
@{The main program}
---

@s Dependencies


We must include the standard I/O definitions, since we want to send formatted output to *stdout* and *stderr*.

--- Header files of system dependencies
// #include <stdio.h>
// // #include <stdlib.h>
// // #include <fcntl.h>
// // #include <unistd.h>
// #include <errno.h>
// #include <string.h>
#include "macros.h"
---

@s Preprocessor macros, includes and exit codes

The `status` variable will tell the operating system if the run was successful or not, 
and `prog_name` is used in case thereâ€™s an error message to be printed.

--- macros.h
#include <stdio.h>
#include <stddef.h>
#include <stdlib.h>
#include <errno.h>
#include <string.h>

#define OK 0                  // status code for successful run
#define usage_error 1         // status code for command not found
#define cannot_open_conf 2    // status code for config file access error

#define ERR(fstr,...) { fprintf(stderr,fstr, ##__VA_ARGS__); fputc('\n',stderr); }
#define XXX(fstr,...) { fprintf(stderr,fstr, ##__VA_ARGS__); fputc('\n',stderr); }
#define ACT(fstr,...) { fprintf(stderr,fstr, ##__VA_ARGS__); fputc('\n',stderr); }

#define MAX_STRING 4096
#define MAX_FILE   1024*100
---

@s Globals

--- Global variables
int status = OK;    // exit status of command, initially OK
char *prog_name;    // who we are
---

@s Input/Output functions

These functions are found inside `io.c` and deal with the reading of contents from a file descriptor.

The current implementation uses `fseek` to determine the file length. The caller should use `file_size` to find out the bytes needed to read the file, then allocate the buffer and pass it as destination to `file_load`.

Future implementations may differ, it is preferable to use the lower level `open/close` interface to conform with both `4.3BSD` and `POSIX.1-2001` specifications.

--- Local functions
// returns size of file descriptor in bytes
extern size_t file_size(FILE *fd);

// reads an amount of bytes from the file descriptor inside dst buffer
extern void file_load(char *dst, size_t bytes, FILE *fd);
---

@s Main

Now we come to the general layout of the `main()` function.

--- The main program
int main(int argc, char **argv)
{
    @{Variables local to main}
    prog_name = argv[0];
    @{Parse command-line options}
    @{Execute the command}
    @{Print any errors}
    return status;
}
---


--- Variables local to main
---

---Parse command-line options
---

---Execute the command
---

---Print any errors
---


